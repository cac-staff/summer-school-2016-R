<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="generator" content="pandoc">
    <title>Software Carpentry: Performance Optimization and Parallelization</title>
    <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" type="text/css" href="css/bootstrap/bootstrap.css" />
    <link rel="stylesheet" type="text/css" href="css/bootstrap/bootstrap-theme.css" />
    <link rel="stylesheet" type="text/css" href="css/swc.css" />
    <link rel="alternate" type="application/rss+xml" title="Software Carpentry Blog" href="http://software-carpentry.org/feed.xml"/>
    <meta charset="UTF-8" />
    <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body class="lesson">
    <div class="container card">
      <div class="banner">
        <a href="http://software-carpentry.org" title="Software Carpentry">
          <img alt="Software Carpentry banner" src="img/software-carpentry-banner.png" />
        </a>
      </div>
      <article>
      <div class="row">
        <div class="col-md-10 col-md-offset-1">
                    <h1 class="title">Performance Optimization and Parallelization</h1>
          <section class="objectives panel panel-warning">
<div class="panel-heading">
<h2 id="learning-objectives"><span class="glyphicon glyphicon-certificate"></span>Learning Objectives</h2>
</div>
<div class="panel-body">
<ul>
<li>Learn how to benchmark code</li>
<li>Understand several common R performance bottlenecks</li>
<li>Properly identify instances where code might benefit from parallelization</li>
<li>Be able to parallelize R code</li>
</ul>
</div>
</section>
<p>Although R is a fantastic tool for data analysis and exploration, speed is not one of its strengths. This is by design - R was made to be easy and powerful to use, and takes many performance shortcuts for the sake of usability. That said, simply knowing several common mistakes to avoid can often reduce the execution times of your scripts from hours to minutes.</p>
<p>Before we start, make sure you have the following packages installed:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">install.packages</span>(<span class="kw">c</span>(<span class="st">&quot;microbenchmark&quot;</span>, <span class="st">&quot;plyr&quot;</span>, <span class="st">&quot;doParallel&quot;</span>))</code></pre></div>
<h2 id="benchmarking">Benchmarking</h2>
<p>Before we can start to cover what slows code down, we’ll need a way of measuring how fast it is. This is called benchmarking. The <code>microbenchmark</code> package provides a very easy way of doing this. Simply give it a piece of code to execute, and it will run your code repeatedly, reporting the amount of time it took to run. Less efficient code is slower.</p>
<p>As an example, let’s generate 100 random numbers and see how long it takes to compute their square root.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(microbenchmark)

randoms &lt;-<span class="st"> </span><span class="kw">runif</span>(<span class="dv">100</span>)
<span class="kw">microbenchmark</span>(<span class="kw">sqrt</span>(randoms))</code></pre></div>
<pre class="output"><code>Unit: microseconds
          expr   min    lq    mean median     uq    max neval
 sqrt(randoms) 1.125 1.181 1.52956  1.231 1.2795 18.272   100
</code></pre>
<p>We can also compare two pieces of code at once. Just specify two pieces of code to compare. In this case, we will compare the execution time of R’s <code>sqrt()</code> function and the <code>^</code> exponent operator for taking a square root.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">microbenchmark</span>(<span class="kw">sqrt</span>(randoms), randoms ^<span class="st"> </span><span class="fl">0.5</span>)</code></pre></div>
<pre class="output"><code>Unit: microseconds
          expr    min     lq     mean median     uq    max neval
 sqrt(randoms)  1.074  1.264  2.27655  1.358  1.511 82.101   100
   randoms^0.5 10.562 10.718 11.91397 10.791 10.891 54.953   100
</code></pre>
<p>After benchmarking it would appear that <code>sqrt()</code> is significantly faster. Using comparisons like this, we’ll be able to figure out what code is good (fast) and what code could use improvement.</p>
<h2 id="common-performance-optimizations">Common performance optimizations</h2>
<p>Although there’s not enough time to cover every possible performance optimization in R, we’ll cover several common mistakes that have a major impact on code performance.</p>
<h3 id="preallocate-for-loops">Preallocate for-loops</h3>
<p>Let’s cover two examples of the same piece of code: in this case, just creating a sequence of numbers of a certain length. For the first case (<code>dynamic</code>), we will grow the variable <code>sequence</code> with each iteration of our loop. In the second case, we will create <code>sequence</code> beforehand at its expected final size.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dynamic &lt;-<span class="st"> </span>function(size) {
  sequence &lt;-<span class="st"> </span><span class="ot">NA</span>
  for (i in <span class="dv">1</span>:size) {
    sequence[i] &lt;-<span class="st"> </span>i
  }
  <span class="kw">return</span>(sequence)
}

preallocated &lt;-<span class="st"> </span>function(size) {
  sequence &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="ot">NA</span>, size)
  for (i in <span class="dv">1</span>:size) {
    sequence[i] &lt;-<span class="st"> </span>i
  }
  <span class="kw">return</span>(sequence)
}

<span class="kw">microbenchmark</span>(<span class="kw">dynamic</span>(<span class="dv">10</span>),
               <span class="kw">dynamic</span>(<span class="dv">100</span>),
               <span class="kw">dynamic</span>(<span class="dv">1000</span>),
               <span class="kw">dynamic</span>(<span class="dv">10000</span>),
               <span class="kw">preallocated</span>(<span class="dv">10</span>),
               <span class="kw">preallocated</span>(<span class="dv">100</span>),
               <span class="kw">preallocated</span>(<span class="dv">1000</span>),
               <span class="kw">preallocated</span>(<span class="dv">10000</span>))</code></pre></div>
<pre class="output"><code>Unit: microseconds
                expr       min         lq         mean      median
         dynamic(10)    11.806    12.9790     19.18848     17.2040
        dynamic(100)   113.567   129.6890    149.95686    143.7180
       dynamic(1000)  1824.694  2004.3175   2964.40888   2207.4025
      dynamic(10000) 93683.446 98295.5590 119174.53041 106747.3370
    preallocated(10)     9.760    11.3130     17.33042     15.0660
   preallocated(100)    78.057    87.0785    118.28348     96.7120
  preallocated(1000)   758.712   825.1315    982.33540    873.1515
 preallocated(10000)  7986.356  8494.2785   9449.82942   9257.7575
         uq        max neval
     23.532     43.067   100
    161.072    247.068   100
   2921.401  47248.725   100
 141109.476 212977.332   100
     22.891     37.607   100
    107.210   1543.479   100
    979.413   4135.261   100
  10008.180  12757.085   100
</code></pre>
<p>Preallocating the <code>sequence</code> variable of our loop performed better in every case. Intriguingly, the speed advantage of preallocating <code>sequence</code> vs. dynamically growing it actually increases with larger sizes. The reason for the difference in speed is caused by how R handles stored objects in memory. Every time it has to make <code>sequence</code> bigger, R actually has to create a copy of <code>sequence</code> at the new size, and then add <code>i</code> to the new object. By preallocating sequence at its final size, we avoid all of this unnecessary copying.</p>
<p>Note that all of the <code>*ply</code> functions from the <code>plyr</code> function do this internally. The easiest way to avoid the pitfalls of dynamically resizing an object is to simply use the corresponding <code>*ply</code> function.</p>
<p>The equivalent <code>*ply</code> function for the last example, compared to <code>preallocated()</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(plyr)

<span class="kw">microbenchmark</span>(
  <span class="kw">preallocated</span>(<span class="dv">10000</span>),
  <span class="kw">llply</span>(<span class="dv">1</span>:<span class="dv">10000</span>, function(x) <span class="kw">return</span>(x)))</code></pre></div>
<pre class="output"><code>Unit: milliseconds
                                  expr      min       lq      mean
                   preallocated(10000) 8.343827 8.891602 10.557074
 llply(1:10000, function(x) return(x)) 7.511032 8.152545  8.827441
   median        uq      max neval
 9.942588 10.590820 60.54052   100
 8.431874  9.731769 11.20537   100
</code></pre>
<h3 id="avoid-creating-unnecessary-variables">Avoid creating unnecessary variables</h3>
<p>The more things you make your computer do, the longer it will take. Saving variables with <code>&lt;-</code> is not always an instantaneous operation, especially if the variables you are saving are comparatively large. In this case we will calculate the mean gdpPercap for a particular country using the <code>gapminder</code> dataset. In our <code>extra_variables()</code> function, we will save all of the data for the country of interest as <code>countryData</code>, then calculate the mean <code>gdpPercap</code>. In the second case, we calculate <code>gdpPercap</code> in a single step.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(gapminder)

extra_variables &lt;-<span class="st"> </span>function(country) {
  countryData &lt;-<span class="st"> </span>gapminder[gapminder$country ==<span class="st"> </span>country, ]
  <span class="kw">return</span>(<span class="kw">mean</span>(countryData$gdpPercap))
}

less_variables &lt;-<span class="st"> </span>function(country) {
  <span class="kw">return</span>(<span class="kw">mean</span>(gapminder$gdpPercap[gapminder$country ==<span class="st"> </span>country]))
}

<span class="kw">microbenchmark</span>(<span class="kw">extra_variables</span>(<span class="st">&quot;Germany&quot;</span>), <span class="kw">less_variables</span>(<span class="st">&quot;Germany&quot;</span>))</code></pre></div>
<pre class="output"><code>Unit: microseconds
                       expr     min      lq     mean   median       uq
 extra_variables(&quot;Germany&quot;) 254.125 269.125 329.0165 289.8060 332.5805
  less_variables(&quot;Germany&quot;) 111.658 114.932 169.9017 118.0665 139.4720
      max neval
 1926.851   100
 1714.942   100
</code></pre>
<p>Using less variables is faster. That said, keep in mind that there is a balance to be struck between having less variables and having readable code. If you do not understand what a piece of code is doing at first glance, it’s a great idea to break it into more readable chunks and add comments that explain what your code is doing.</p>
<h3 id="use-vectorized-code">Use vectorized code</h3>
<p>Many of R’s core functions use actually use ultra-fast code written in other programming languages like C and Fortran. One major example of this is using R’s vectorized operators and functions (that take a vector as input and return a vector as output). One example of this is adding a number to a vector: in the first case, we will simply add 10 to a set of 1000 random numbers with the <code>+</code> operator. In the second case, we will loop over all 1000 numbers and add 10 to each.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">randoms &lt;-<span class="st"> </span><span class="kw">runif</span>(<span class="dv">1000</span>)

<span class="kw">microbenchmark</span>(randoms +<span class="st"> </span><span class="dv">10</span>, 
               for (i in <span class="dv">1</span>:<span class="dv">1000</span>) {
                 randoms[i] +<span class="st"> </span><span class="dv">10</span>
               })</code></pre></div>
<pre class="output"><code>Unit: microseconds
                                      expr     min       lq      mean
                              randoms + 10   1.819   2.3455   3.72634
 for (i in 1:1000) {     randoms[i] + 10 } 355.607 400.9680 469.42714
   median       uq      max neval
   2.9195   3.2900   43.062   100
 444.2645 482.1175 1699.012   100
</code></pre>
<p>Although the computer is in fact performing the same operation in both cases (it loops over the vector), the vectorized operation is almost 200x faster because it is using an ultra-fast implementation written in another language.</p>
<h3 id="avoid-repeatedly-writing-or-reading-from-disk">Avoid repeatedly writing or reading from disk</h3>
<p>Using the hard disk on your computer is an extremely slow operation. Objects stored in memory (the R workspace) are orders of magnitude faster to access. If one of your scripts is reading or writing to disk repeatedly, your code will be limited by your disk I/O speed.</p>
<p>As an example of this, we will save the data from a country as a in memory and then read it back. We will then do the same thing, but instead of using memory, we will save it to disk and then read it back.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">memory &lt;-<span class="st"> </span>function(country) {
  data &lt;-<span class="st"> </span>gapminder[gapminder$country ==<span class="st"> </span>country, ]
  <span class="kw">return</span>(data)
}

disk &lt;-<span class="st"> </span>function(country) {
  <span class="kw">write.csv</span>(gapminder[gapminder$country ==<span class="st"> </span>country, ], 
            <span class="dt">file =</span> <span class="st">&quot;temp.csv&quot;</span>, <span class="dt">row.names =</span> <span class="ot">FALSE</span>)
  <span class="kw">return</span>(<span class="kw">read.csv</span>(<span class="st">&quot;temp.csv&quot;</span>, <span class="dt">as.is =</span> <span class="ot">TRUE</span>))
}

<span class="kw">microbenchmark</span>(<span class="kw">memory</span>(<span class="st">&quot;Germany&quot;</span>), <span class="kw">disk</span>(<span class="st">&quot;Germany&quot;</span>))</code></pre></div>
<pre class="output"><code>Unit: microseconds
              expr      min        lq      mean    median        uq
 memory(&quot;Germany&quot;)  238.873  280.2125  399.4956  312.1265  370.1595
   disk(&quot;Germany&quot;) 1776.537 2096.0815 2876.5894 2522.1570 3106.0465
      max neval
 3877.785   100
 9494.601   100
</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">file.remove</span>(<span class="st">&quot;temp.csv&quot;</span>)  <span class="co"># clean up after ourselves</span></code></pre></div>
<pre class="output"><code>[1] TRUE
</code></pre>
<h2 id="parallelization-with-plyr-and-doparallel">Parallelization with <code>plyr</code> and <code>doParallel</code></h2>
<p>One final way to have code run faster is to simply run it with more computing power. Keep in mind however, that faster code will <em>always</em> beat faster hardware. As we’ve shown in previous examples, optimizing your code can often result in it running hundreds, if not thousands of times faster. The performance boost offered by parallelizing code is comparatively modest and is limited by the number of CPUs you have available.</p>
<p>Furthermore, some code simply cannot be parallelized. At its heart, all parallel computing involves splitting a large operation into separate chunks, performing operations on separate pieces of hardware, and then aggregating the results. If one operation depends on the last or otherwise modifies a variable used by other processes, it cannot be done in parallel.</p>
<p>Put more simply, problems that are a good fit for parallel computing typically meet the following criteria:</p>
<ul>
<li>The code takes a long time to execute</li>
<li>Each computation is completely independent of other computations</li>
<li>The code has already been optimized as much as possible</li>
</ul>
<p>With that said, let’s write some parallel code! We will use <code>plyr</code> and the <code>doParallel</code> package, as those packages are easy to use and can be run on any OS (OSX/Linux/Windows).</p>
<p>How many cores do we have available?</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(doParallel)</code></pre></div>
<pre class="output"><code>Loading required package: foreach
</code></pre>
<pre class="output"><code>Loading required package: iterators
</code></pre>
<pre class="output"><code>Loading required package: parallel
</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">detectCores</span>()</code></pre></div>
<pre class="output"><code>[1] 4
</code></pre>
<p>The machine this tutorial was written on has 4 cores. Let’s use ’em. For our example calculation, we will actually cheat a bit and make function that just returns the mean gdp for a country / 1000 (from <code>gapminder</code>) after waiting for a fraction of a second. The process for parallelization on is slightly different between UNIX (OSX/Linux) and Windows.</p>
<h3 id="on-osxlinux">On OSX/Linux</h3>
<p>To parallelize a function using one of the <code>*ply</code> functions, it’s as simple as registering a parallel backend with <code>registerDoParallel(cores)</code> once in your script and adding the argument <code>.parallel = TRUE</code> to the <code>*ply</code> function you want to use. That’s it - you’re done!</p>
<p>So the parallel workflow looks like this:</p>
<ul>
<li><code>registerDoParallel(cores)</code></li>
<li>Parallel calculations with <code>plyr</code></li>
</ul>
<p>A sample parallel script on OSX/Linux might look like this:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(plyr)
<span class="kw">library</span>(microbenchmark)
<span class="kw">library</span>(gapminder)
<span class="kw">library</span>(doParallel)

<span class="kw">registerDoParallel</span>(<span class="dt">cores =</span> <span class="kw">detectCores</span>())

someVariable &lt;-<span class="st"> </span><span class="dv">1000</span>

fakefunc &lt;-<span class="st"> </span>function(country) {
  <span class="kw">Sys.sleep</span>(<span class="fl">0.2</span>)
  df &lt;-<span class="st"> </span>gapminder[gapminder$country ==<span class="st"> </span>country, ]
  toReturn &lt;-<span class="st"> </span><span class="kw">data.frame</span>(country, <span class="dt">gdp =</span> <span class="kw">mean</span>(df$gdpPercap) /<span class="st"> </span>someVariable)
  <span class="kw">return</span>(toReturn)
}

<span class="kw">microbenchmark</span>(
  <span class="kw">laply</span>(<span class="kw">unique</span>(gapminder$country), fakefunc),
  <span class="kw">laply</span>(<span class="kw">unique</span>(gapminder$country), fakefunc, <span class="dt">.parallel =</span> <span class="ot">TRUE</span>),
  <span class="dt">times =</span> <span class="dv">1</span>)</code></pre></div>
<pre class="output"><code>Unit: seconds
                                                         expr       min
                   laply(unique(gapminder$country), fakefunc) 28.780111
 laply(unique(gapminder$country), fakefunc, .parallel = TRUE)  7.486148
        lq      mean    median        uq       max neval
 28.780111 28.780111 28.780111 28.780111 28.780111     1
  7.486148  7.486148  7.486148  7.486148  7.486148     1
</code></pre>
<h3 id="on-windows">On Windows</h3>
<p>Parallelizing a function on Windows is slightly harder than on OSX/Linux. On OSX/Linux, the workspace is copied to all of the parallel processes you use. On Windows, the parallel R processes must be manually created and variables and functions must be passed to your parallel R workers (this is done with the <code>.paropts</code> argument to <code>*ply</code>. Finally, once you are done using R in parallel (like at the end of your script), you must stop your parallel R workers with <code>stopImplicitCluster()</code> or they will hang around and continue to eat up system resources.</p>
<p>On Windows, a sample parallel workflow looks like this:</p>
<ul>
<li><code>registerDoParallel(cores)</code></li>
<li>Parallel calculations with <code>plyr</code> (must use <code>.paropts</code> to pass variables and packages). <code>.paropts</code> typically looks like <code>.paropts = list(.packages = c(&quot;package1&quot;, &quot;package2&quot;), .export = c(&quot;variableName1&quot;, &quot;functionName2&quot;))</code></li>
<li><code>stopImplicitCluster()</code></li>
</ul>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(microbenchmark)
<span class="kw">library</span>(plyr)
<span class="kw">library</span>(doParallel)
<span class="kw">library</span>(gapminder)

<span class="co"># start parallel workers</span>
<span class="kw">registerDoParallel</span>(<span class="dt">cores =</span> <span class="kw">detectCores</span>())

someVariable &lt;-<span class="st"> </span><span class="dv">1000</span>

fakefunc &lt;-<span class="st"> </span>function(country) {
  <span class="kw">Sys.sleep</span>(<span class="fl">0.2</span>)
  df &lt;-<span class="st"> </span>gapminder[gapminder$country ==<span class="st"> </span>country, ]
  toReturn &lt;-<span class="st"> </span><span class="kw">data.frame</span>(country, <span class="dt">gdp =</span> <span class="kw">mean</span>(df$gdpPercap) /<span class="st"> </span>someVariable)
  <span class="kw">return</span>(toReturn)
}

<span class="kw">microbenchmark</span>(
  <span class="kw">ldply</span>(<span class="kw">unique</span>(gapminder$country), fakefunc),
  <span class="kw">ldply</span>(<span class="kw">unique</span>(gapminder$country), fakefunc, <span class="dt">.parallel =</span> <span class="ot">TRUE</span>, 
        <span class="dt">.paropts =</span> <span class="kw">list</span>(<span class="dt">.packages =</span> <span class="st">&quot;gapminder&quot;</span>, <span class="dt">.export =</span> <span class="kw">c</span>(<span class="st">&quot;someVariable&quot;</span>))),
  <span class="dt">times =</span> <span class="dv">1</span>)

<span class="co"># kill parallel workers</span>
<span class="kw">stopImplicitCluster</span>()</code></pre></div>
        </div>
      </div>
      </article>
      <div class="footer">
        <a class="label swc-blue-bg" href="http://software-carpentry.org">Software Carpentry</a>
        <a class="label swc-blue-bg" href="https://github.com/swcarpentry/r-novice-gapminder">Source</a>
        <a class="label swc-blue-bg" href="mailto:admin@software-carpentry.org">Contact</a>
        <a class="label swc-blue-bg" href="LICENSE.html">License</a>
      </div>
    </div>
    <!-- Javascript placed at the end of the document so the pages load faster -->
    <script src="http://software-carpentry.org/v5/js/jquery-1.9.1.min.js"></script>
    <script src="css/bootstrap/bootstrap-js/bootstrap.js"></script>
    <script src='https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'></script>
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
    
      ga('create', 'UA-37305346-2', 'auto');
      ga('send', 'pageview');
    
    </script>
  </body>
</html>
