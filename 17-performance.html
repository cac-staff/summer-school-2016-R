<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="generator" content="pandoc">
    <title>Software Carpentry: Performance Optimization and Parallelization</title>
    <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" type="text/css" href="css/bootstrap/bootstrap.css" />
    <link rel="stylesheet" type="text/css" href="css/bootstrap/bootstrap-theme.css" />
    <link rel="stylesheet" type="text/css" href="css/swc.css" />
    <link rel="alternate" type="application/rss+xml" title="Software Carpentry Blog" href="http://software-carpentry.org/feed.xml"/>
    <meta charset="UTF-8" />
    <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body class="lesson">
    <div class="container card">
      <div class="banner">
        <a href="http://software-carpentry.org" title="Software Carpentry">
          <img alt="Software Carpentry banner" src="img/software-carpentry-banner.png" />
        </a>
      </div>
      <article>
      <div class="row">
        <div class="col-md-10 col-md-offset-1">
                    <h1 class="title">Performance Optimization and Parallelization</h1>
          <section class="objectives panel panel-warning">
<div class="panel-heading">
<h2 id="learning-objectives"><span class="glyphicon glyphicon-certificate"></span>Learning Objectives</h2>
</div>
<div class="panel-body">
<ul>
<li>Learn how to benchmark code</li>
<li>Understand several common R performance bottlenecks</li>
<li>Properly identify instances where code might benefit from parallelization</li>
<li>Be able to parallelize R code</li>
</ul>
</div>
</section>
<p>Although R is a fantastic tool for data analysis and exploration, speed is not one of its strengths. This is by design - R was made to be easy and powerful to use, and takes many performance shortcuts for the sake of usability. That said, simply knowing several common mistakes to avoid can often reduce the execution times of your scripts from hours to minutes.</p>
<p>Before we start, make sure you have the following packages installed:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">install.packages</span>(<span class="kw">c</span>(<span class="st">&quot;microbenchmark&quot;</span>, <span class="st">&quot;plyr&quot;</span>, <span class="st">&quot;doParallel&quot;</span>))</code></pre></div>
<h2 id="benchmarking">Benchmarking</h2>
<p>Before we can start to cover what slows code down, we’ll need a way of measuring how fast it is. This is called benchmarking. The <code>microbenchmark</code> package provides a very easy way of doing this. Simply give it a piece of code to execute, and it will run your code repeatedly, reporting the amount of time it took to run. Less efficient code is slower.</p>
<p>As an example, let’s generate 100 random numbers and see how long it takes to compute their square root.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(microbenchmark)

randoms &lt;-<span class="st"> </span><span class="kw">runif</span>(<span class="dv">100</span>)
<span class="kw">microbenchmark</span>(<span class="kw">sqrt</span>(randoms))</code></pre></div>
<pre class="output"><code>Unit: microseconds
          expr   min    lq    mean median    uq    max neval
 sqrt(randoms) 1.118 1.257 1.48609 1.2985 1.334 17.515   100
</code></pre>
<p>We can also compare two pieces of code at once. Just specify two pieces of code to compare. In this case, we will compare the execution time of R’s <code>sqrt()</code> function and the <code>^</code> exponent operator for taking a square root.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">microbenchmark</span>(<span class="kw">sqrt</span>(randoms), randoms ^<span class="st"> </span><span class="fl">0.5</span>)</code></pre></div>
<pre class="output"><code>Unit: microseconds
          expr    min      lq     mean median      uq     max neval
 sqrt(randoms)  1.102  1.2700  1.71767  1.377  1.5485  17.973   100
   randoms^0.5 10.590 10.7765 15.94200 10.874 11.2030 298.370   100
</code></pre>
<p>After benchmarking it would appear that <code>sqrt()</code> is significantly faster. Using comparisons like this, we’ll be able to figure out what code is good (fast) and what code could use improvement.</p>
<h2 id="common-performance-optimizations">Common performance optimizations</h2>
<p>Although there’s not enough time to cover every possible performance optimization in R, we’ll cover several common mistakes that have a major impact on code performance.</p>
<h3 id="preallocate-for-loops">Preallocate for-loops</h3>
<p>Let’s cover two examples of the same piece of code: in this case, just creating a sequence of numbers of a certain length. For the first case (<code>dynamic</code>), we will grow the variable <code>sequence</code> with each iteration of our loop. In the second case, we will create <code>sequence</code> beforehand at its expected final size.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dynamic &lt;-<span class="st"> </span>function(size) {
  sequence &lt;-<span class="st"> </span><span class="ot">NA</span>
  for (i in <span class="dv">1</span>:size) {
    sequence[i] &lt;-<span class="st"> </span>i
  }
  <span class="kw">return</span>(sequence)
}

preallocated &lt;-<span class="st"> </span>function(size) {
  sequence &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="ot">NA</span>, size)
  for (i in <span class="dv">1</span>:size) {
    sequence[i] &lt;-<span class="st"> </span>i
  }
  <span class="kw">return</span>(sequence)
}

<span class="kw">microbenchmark</span>(<span class="kw">dynamic</span>(<span class="dv">10</span>),
               <span class="kw">dynamic</span>(<span class="dv">100</span>),
               <span class="kw">dynamic</span>(<span class="dv">1000</span>),
               <span class="kw">dynamic</span>(<span class="dv">10000</span>),
               <span class="kw">preallocated</span>(<span class="dv">10</span>),
               <span class="kw">preallocated</span>(<span class="dv">100</span>),
               <span class="kw">preallocated</span>(<span class="dv">1000</span>),
               <span class="kw">preallocated</span>(<span class="dv">10000</span>))</code></pre></div>
<pre class="output"><code>Unit: microseconds
                expr       min          lq         mean      median
         dynamic(10)    12.013     14.1545     21.08508     16.9640
        dynamic(100)   116.729    133.5830    158.08893    145.4185
       dynamic(1000)  1836.242   2142.1455   3189.47906   2663.8300
      dynamic(10000) 92574.725 100751.2375 120766.04840 109819.2705
    preallocated(10)     9.923     11.9220     18.89082     17.7230
   preallocated(100)    81.102     88.6555    103.51341     95.1705
  preallocated(1000)   776.135    852.0280   1004.88944    907.9835
 preallocated(10000)  8187.022   8579.1210   9595.38399   9130.6060
          uq        max neval
     24.3220     79.757   100
    173.2030    279.465   100
   3094.8480  45449.344   100
 142190.6030 205317.575   100
     22.7275     97.232   100
    110.0850    226.714   100
   1037.4640   2639.557   100
  10290.4660  13649.102   100
</code></pre>
<p>Preallocating the <code>sequence</code> variable of our loop performed better in every case. Intriguingly, the speed advantage of preallocating <code>sequence</code> vs. dynamically growing it actually increases with larger sizes. The reason for the difference in speed is caused by how R handles stored objects in memory. Every time it has to make <code>sequence</code> bigger, R actually has to create a copy of <code>sequence</code> at the new size, and then add <code>i</code> to the new object. By preallocating sequence at its final size, we avoid all of this unnecessary copying.</p>
<p>Note that all of the <code>*ply</code> functions from the <code>plyr</code> function do this internally. The easiest way to avoid the pitfalls of dynamically resizing an object is to simply use the corresponding <code>*ply</code> function.</p>
<p>The equivalent <code>*ply</code> function for the last example, compared to <code>preallocated()</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(plyr)

<span class="kw">microbenchmark</span>(
  <span class="kw">preallocated</span>(<span class="dv">10000</span>),
  <span class="kw">llply</span>(<span class="dv">1</span>:<span class="dv">10000</span>, function(x) <span class="kw">return</span>(x)))</code></pre></div>
<pre class="output"><code>Unit: milliseconds
                                  expr      min       lq      mean
                   preallocated(10000) 8.343753 8.805730 10.772959
 llply(1:10000, function(x) return(x)) 7.377793 7.892931  8.805502
   median        uq      max neval
 10.02329 11.242248 67.28878   100
  8.62486  9.408815 11.17397   100
</code></pre>
<h3 id="avoid-creating-unnecessary-variables">Avoid creating unnecessary variables</h3>
<p>The more things you make your computer do, the longer it will take. Saving variables with <code>&lt;-</code> is not always an instantaneous operation, especially if the variables you are saving are comparatively large. In this case we will calculate the mean gdpPercap for a particular country using the <code>gapminder</code> dataset. In our <code>extra_variables()</code> function, we will save all of the data for the country of interest as <code>countryData</code>, then calculate the mean <code>gdpPercap</code>. In the second case, we calculate <code>gdpPercap</code> in a single step.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(gapminder)

extra_variables &lt;-<span class="st"> </span>function(country) {
  countryData &lt;-<span class="st"> </span>gapminder[gapminder$country ==<span class="st"> </span>country, ]
  <span class="kw">return</span>(<span class="kw">mean</span>(countryData$gdpPercap))
}

less_variables &lt;-<span class="st"> </span>function(country) {
  <span class="kw">return</span>(<span class="kw">mean</span>(gapminder$gdpPercap[gapminder$country ==<span class="st"> </span>country]))
}

<span class="kw">microbenchmark</span>(<span class="kw">extra_variables</span>(<span class="st">&quot;Germany&quot;</span>), <span class="kw">less_variables</span>(<span class="st">&quot;Germany&quot;</span>))</code></pre></div>
<pre class="output"><code>Unit: microseconds
                       expr     min       lq     mean  median       uq
 extra_variables(&quot;Germany&quot;) 253.530 258.5945 360.6558 274.616 321.8900
  less_variables(&quot;Germany&quot;) 110.416 113.5490 133.6912 115.664 145.1995
      max neval
 2410.062   100
  375.777   100
</code></pre>
<p>Using less variables is faster. That said, keep in mind that there is a balance to be struck between having less variables and having readable code. If you do not understand what a piece of code is doing at first glance, it’s a great idea to break it into more readable chunks and add comments that explain what your code is doing.</p>
<h3 id="use-vectorized-code">Use vectorized code</h3>
<p>Many of R’s core functions use actually use ultra-fast code written in other programming languages like C and Fortran. One major example of this is using R’s vectorized operators and functions (that take a vector as input and return a vector as output). One example of this is adding a number to a vector: in the first case, we will simply add 10 to a set of 1000 random numbers with the <code>+</code> operator. In the second case, we will loop over all 1000 numbers and add 10 to each.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">randoms &lt;-<span class="st"> </span><span class="kw">runif</span>(<span class="dv">1000</span>)

<span class="kw">microbenchmark</span>(randoms +<span class="st"> </span><span class="dv">10</span>, 
               for (i in <span class="dv">1</span>:<span class="dv">1000</span>) {
                 randoms[i] +<span class="st"> </span><span class="dv">10</span>
               })</code></pre></div>
<pre class="output"><code>Unit: microseconds
                                      expr     min       lq      mean
                              randoms + 10   2.285   2.5485   3.89762
 for (i in 1:1000) {     randoms[i] + 10 } 354.520 403.1360 497.57094
   median       uq      max neval
   3.0245   3.7370   29.299   100
 460.2490 530.2925 2293.270   100
</code></pre>
<p>Although the computer is in fact performing the same operation in both cases (it loops over the vector), the vectorized operation is almost 200x faster because it is using an ultra-fast implementation written in another language.</p>
<h3 id="avoid-repeatedly-writing-or-reading-from-disk">Avoid repeatedly writing or reading from disk</h3>
<p>Using the hard disk on your computer is an extremely slow operation. Objects stored in memory (the R workspace) are orders of magnitude faster to access. If one of your scripts is reading or writing to disk repeatedly, your code will be limited by your disk I/O speed.</p>
<p>As an example of this, we will save the data from a country as a in memory and then read it back. We will then do the same thing, but instead of using memory, we will save it to disk and then read it back.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">memory &lt;-<span class="st"> </span>function(country) {
  data &lt;-<span class="st"> </span>gapminder[gapminder$country ==<span class="st"> </span>country, ]
  <span class="kw">return</span>(data)
}

disk &lt;-<span class="st"> </span>function(country) {
  <span class="kw">write.csv</span>(gapminder[gapminder$country ==<span class="st"> </span>country, ], 
            <span class="dt">file =</span> <span class="st">&quot;temp.csv&quot;</span>, <span class="dt">row.names =</span> <span class="ot">FALSE</span>)
  <span class="kw">return</span>(<span class="kw">read.csv</span>(<span class="st">&quot;temp.csv&quot;</span>, <span class="dt">as.is =</span> <span class="ot">TRUE</span>))
}

<span class="kw">microbenchmark</span>(<span class="kw">memory</span>(<span class="st">&quot;Germany&quot;</span>), <span class="kw">disk</span>(<span class="st">&quot;Germany&quot;</span>))</code></pre></div>
<pre class="output"><code>Unit: microseconds
              expr      min        lq      mean    median        uq
 memory(&quot;Germany&quot;)  242.075  275.7285  380.5267  304.1155  345.0335
   disk(&quot;Germany&quot;) 1901.962 2040.0400 2381.5342 2154.5500 2419.0180
      max neval
 3193.915   100
 7233.583   100
</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">file.remove</span>(<span class="st">&quot;temp.csv&quot;</span>)  <span class="co"># clean up after ourselves</span></code></pre></div>
<pre class="output"><code>[1] TRUE
</code></pre>
<h2 id="parallelization-with-plyr-and-doparallel">Parallelization with <code>plyr</code> and <code>doParallel</code></h2>
<p>One final way to have code run faster is to simply run it with more computing power. Keep in mind however, that faster code will <em>always</em> beat faster hardware. As we’ve shown in previous examples, optimizing your code can often result in it running hundreds, if not thousands of times faster. The performance boost offered by parallelizing code is comparatively modest and is limited by the number of CPUs you have available.</p>
<p>Furthermore, some code simply cannot be parallelized. At its heart, all parallel computing involves splitting a large operation into separate chunks, performing operations on separate pieces of hardware, and then aggregating the results. If one operation depends on the last or otherwise modifies a variable used by other processes, it cannot be done in parallel.</p>
<p>Put more simply, problems that are a good fit for parallel computing typically meet the following criteria:</p>
<ul>
<li>The code takes a long time to execute</li>
<li>Each computation is completely independent of other computations</li>
<li>The code has already been optimized as much as possible</li>
</ul>
<p>With that said, let’s write some parallel code! We will use <code>plyr</code> and the <code>doParallel</code> package, as those packages are easy to use and can be run on any OS (OSX/Linux/Windows).</p>
<p>How many cores do we have available?</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(doParallel)</code></pre></div>
<pre class="output"><code>Loading required package: foreach
</code></pre>
<pre class="output"><code>Loading required package: iterators
</code></pre>
<pre class="output"><code>Loading required package: parallel
</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">detectCores</span>()</code></pre></div>
<pre class="output"><code>[1] 4
</code></pre>
<p>The machine this tutorial was written on has 4 cores. Let’s use ’em. For our example calculation, we will actually cheat a bit and make function that just returns the mean gdp for a country / 1000 (from <code>gapminder</code>) after waiting for a fraction of a second. The process for parallelization on is slightly different between UNIX (OSX/Linux) and Windows.</p>
<h3 id="on-osxlinux">On OSX/Linux</h3>
<p>To parallelize a function using one of the <code>*ply</code> functions, it’s as simple as registering a parallel backend with <code>registerDoParallel(cores)</code> once in your script and adding the argument <code>.parallel = TRUE</code> to the <code>*ply</code> function you want to use. That’s it - you’re done!</p>
<p>So the parallel workflow looks like this:</p>
<ul>
<li><code>registerDoParallel(cores)</code></li>
<li>Parallel calculations with <code>plyr</code></li>
</ul>
<p>A sample parallel script on OSX/Linux might look like this:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(plyr)
<span class="kw">library</span>(microbenchmark)
<span class="kw">library</span>(gapminder)
<span class="kw">library</span>(doParallel)

<span class="kw">registerDoParallel</span>(<span class="dt">cores =</span> <span class="kw">detectCores</span>())

someVariable &lt;-<span class="st"> </span><span class="dv">1000</span>

fakefunc &lt;-<span class="st"> </span>function(country) {
  <span class="kw">Sys.sleep</span>(<span class="fl">0.2</span>)
  df &lt;-<span class="st"> </span>gapminder[gapminder$country ==<span class="st"> </span>country, ]
  toReturn &lt;-<span class="st"> </span><span class="kw">data.frame</span>(country, <span class="dt">gdp =</span> <span class="kw">mean</span>(df$gdpPercap) /<span class="st"> </span>someVariable)
  <span class="kw">return</span>(toReturn)
}

<span class="kw">microbenchmark</span>(
  <span class="kw">laply</span>(<span class="kw">unique</span>(gapminder$country), fakefunc),
  <span class="kw">laply</span>(<span class="kw">unique</span>(gapminder$country), fakefunc, <span class="dt">.parallel =</span> <span class="ot">TRUE</span>),
  <span class="dt">times =</span> <span class="dv">1</span>)</code></pre></div>
<pre class="output"><code>Unit: seconds
                                                         expr       min
                   laply(unique(gapminder$country), fakefunc) 28.821741
 laply(unique(gapminder$country), fakefunc, .parallel = TRUE)  7.530481
        lq      mean    median        uq       max neval
 28.821741 28.821741 28.821741 28.821741 28.821741     1
  7.530481  7.530481  7.530481  7.530481  7.530481     1
</code></pre>
<h3 id="on-windows">On Windows</h3>
<p>Parallelizing a function on Windows is slightly harder than on OSX/Linux. On OSX/Linux, the workspace is copied to all of the parallel processes you use. On Windows, the parallel R processes must be manually created and variables and functions must be passed to your parallel R workers (this is done with the <code>.paropts</code> argument to <code>*ply</code>. Finally, once you are done using R in parallel (like at the end of your script), you must stop your parallel R workers with <code>stopImplicitCluster()</code> or they will hang around and continue to eat up system resources.</p>
<p>On Windows, a sample parallel workflow looks like this:</p>
<ul>
<li><code>registerDoParallel(cores)</code></li>
<li>Parallel calculations with <code>plyr</code> (must use <code>.paropts</code> to pass variables and packages). <code>.paropts</code> typically looks like <code>.paropts = list(.packages = c(&quot;package1&quot;, &quot;package2&quot;), .export = c(&quot;variableName1&quot;, &quot;functionName2&quot;))</code></li>
<li><code>stopImplicitCluster()</code></li>
</ul>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(microbenchmark)
<span class="kw">library</span>(plyr)
<span class="kw">library</span>(doParallel)
<span class="kw">library</span>(gapminder)

<span class="co"># start parallel workers</span>
<span class="kw">registerDoParallel</span>(<span class="dt">cores =</span> <span class="kw">detectCores</span>())

someVariable &lt;-<span class="st"> </span><span class="dv">1000</span>

fakefunc &lt;-<span class="st"> </span>function(country) {
  <span class="kw">Sys.sleep</span>(<span class="fl">0.2</span>)
  df &lt;-<span class="st"> </span>gapminder[gapminder$country ==<span class="st"> </span>country, ]
  toReturn &lt;-<span class="st"> </span><span class="kw">data.frame</span>(country, <span class="dt">gdp =</span> <span class="kw">mean</span>(df$gdpPercap) /<span class="st"> </span>someVariable)
  <span class="kw">return</span>(toReturn)
}

<span class="kw">microbenchmark</span>(
  <span class="kw">ldply</span>(<span class="kw">unique</span>(gapminder$country), fakefunc),
  <span class="kw">ldply</span>(<span class="kw">unique</span>(gapminder$country), fakefunc, <span class="dt">.parallel =</span> <span class="ot">TRUE</span>, 
        <span class="dt">.paropts =</span> <span class="kw">list</span>(<span class="dt">.packages =</span> <span class="st">&quot;gapminder&quot;</span>, <span class="dt">.export =</span> <span class="kw">c</span>(<span class="st">&quot;someVariable&quot;</span>))),
  <span class="dt">times =</span> <span class="dv">1</span>)

<span class="co"># kill parallel workers</span>
<span class="kw">stopImplicitCluster</span>()</code></pre></div>
<h3 id="final-notes">Final notes</h3>
<p>Sometimes, if what you’re parallelizing is very fast, your code make actually run <em>slower</em> when in parallel. Every parallel iteration of your <code>*ply</code> function involves splitting up your job and sending it to the different parallel R workers. If individual iterations run slower in parallel, it is likely that your function is spending more time splitting up the job to run it on multiple cores than it is doing actual work. These types of jobs should not be done in parallel.</p>
<p>Attempting to <code>registerDoParallel(cores)</code> with more cores than your machine actually has will slow down your job. If you tried to do a 16 core computation on a machine that only has 4 cores, for instance, the 16 R workers will be forced to take turns on your available CPUs, resulting in them running at roughly 25% speed. For the same reason, do not put a parallel function inside another parallel function. Something like this: <code>**ply(data, function(x) {**ply(data, fun, .parallel = TRUE)}), .parallel = TRUE)</code> will only end badly.</p>
<p>Finally when running a parallel R job on a compute cluster, <strong>NEVER</strong> do this: <code>registerDoParallel(cores = detectCores())</code>. This will attempt to use every available CPU (including ones you have not been allocated), potentially ruining other jobs on a compute node. You must register a fixed number of cores (<code>registerDoParallel(cores = 4)</code> for instance), and then request that number of cores from the scheduler.</p>
        </div>
      </div>
      </article>
      <div class="footer">
        <a class="label swc-blue-bg" href="http://software-carpentry.org">Software Carpentry</a>
        <a class="label swc-blue-bg" href="https://github.com/swcarpentry/r-novice-gapminder">Source</a>
        <a class="label swc-blue-bg" href="mailto:admin@software-carpentry.org">Contact</a>
        <a class="label swc-blue-bg" href="LICENSE.html">License</a>
      </div>
    </div>
    <!-- Javascript placed at the end of the document so the pages load faster -->
    <script src="http://software-carpentry.org/v5/js/jquery-1.9.1.min.js"></script>
    <script src="css/bootstrap/bootstrap-js/bootstrap.js"></script>
    <script src='https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'></script>
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
    
      ga('create', 'UA-37305346-2', 'auto');
      ga('send', 'pageview');
    
    </script>
  </body>
</html>
